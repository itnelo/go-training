package basics

import (
	"fmt"
	"math/rand"
	"time"
)

// Go supports Unicode identifiers (lol)

//
// A sign enum
//

type Знак byte

const (
	Аард Знак = iota
	Аксий
	Гелиотроп
	Игни
	Ирден
	Квен
	Сомн
)

var знаки = []string{
	"Аард",
	"Аксий",
	"Гелиотроп",
	"Игни",
	"Ирден",
	"Квен",
	"Сомн",
}

// A stringer for a enumeration type
func (рунический Знак) String() string {
	if рунический > Сомн {
		panic("Такого знака нет. В енуме Сомн является последним знаком!")
	}

	return знаки[рунический]
}

//
// An object state
//

type Самочувствие struct {
	здоровье uint
}

//
// Actor behaviors
//

type Чувствующий interface {
	оценитьСамочувствие() *Самочувствие
}

//
// Actors on scene
//

type Ведьмак struct {
	имя        string
	рунический Знак
	ухудшаемое Самочувствие
}

// implementing "Чувствующий" interface
func (чувствующий *Ведьмак) оценитьСамочувствие() (ведьмачье *Самочувствие) {
	ведьмачье = &чувствующий.ухудшаемое

	return
}

// stringer (string serialization)
func (сериализующийся *Ведьмак) String() string {
	return fmt.Sprintf(
		"Ведьмак %v (%v здоровья, выбран %v)",
		сериализующийся.имя,
		сериализующийся.ухудшаемое.здоровье,
		сериализующийся.рунический)
}

func (подготавливающийся *Ведьмак) выбратьЗнак(рунический Знак) {
	подготавливающийся.рунический = рунический

	fmt.Printf("%v выбрал знак %v\n", подготавливающийся, рунический)
}

func (кастующий *Ведьмак) ухудшитьСамочувствие(цель interface{}) {
	if сейчасПолучит, можноВтащить := цель.(Чувствующий); можноВтащить {
		var самочувствие = сейчасПолучит.оценитьСамочувствие()
		var генераторУрона = генераторУронаОтЗнаков()

		урон := генераторУрона()

		if самочувствие.здоровье >= урон {
			самочувствие.здоровье -= урон
		} else {
			самочувствие.здоровье = 0

			defer func() {
				fmt.Printf("%v погибает\n", цель)
			}()
		}

		fmt.Printf("%v получает %v урона\n", цель, урон)

		return
	}

	panic(fmt.Errorf("Нельзя втащить этой цели, т.к. она ничего не чувствует"))
}

func (убегающий *Ведьмак) убежать() {
	fmt.Printf("%v убежал, т.к. не смог втащить\n", убегающий)
}

//
// A ghoul
//

type Гуль struct {
	ухудшаемое Самочувствие
}

// stringer
func (сериализующийся *Гуль) String() string {
	return fmt.Sprintf("Гуль (%v здоровья)", сериализующийся.ухудшаемое.здоровье)
}

func (чувствующий *Гуль) оценитьСамочувствие() (чудовищное *Самочувствие) {
	чудовищное = &чувствующий.ухудшаемое

	return
}

//
// Helpers
//

func генераторУронаОтЗнаков() func() uint {
	var generatorSeed int64 = time.Now().UnixNano() / int64(time.Nanosecond)
	fmt.Println("Generator seed:", generatorSeed)

	rand.Seed(generatorSeed)

	return func() (урон uint) {
		урон = uint(rand.Intn(3000))

		return
	}
}

func светКамераМотор() {
	Ламберт := &Ведьмак{
		имя:        "Ламберт",
		рунический: Знак(Аард),
		ухудшаемое: Самочувствие{4500},
	}

	fmt.Printf("An instance of Ведьмак has been created:\n%v\n", Ламберт)

	var недоброжелатели = []Гуль{
		Гуль{Самочувствие{1500}},
		Гуль{Самочувствие{700}},
		Гуль{Самочувствие{800}},
	}

	fmt.Printf("A slice of Гуль has been created:\n%+v\n", недоброжелатели)

	Ламберт.выбратьЗнак(Игни)

	defer func(оплошавший *Ведьмак) {
		if r := recover(); r != nil {
			if _, нормас := r.(error); нормас {
				оплошавший.убежать()
			}
		}
	}(Ламберт)

	for порядковыйНомер, _ := range недоброжелатели {
		Ламберт.ухудшитьСамочувствие(&недоброжелатели[порядковыйНомер])
	}

	// An instance of Ведьмак has been created:
	// Ведьмак Ламберт (4500 здоровья, выбран Аард)
	// A slice of Гуль has been created:
	// [{ухудшаемое:{здоровье:1500}} {ухудшаемое:{здоровье:700}} {ухудшаемое:{здоровье:800}}]
	// Ведьмак Ламберт (4500 здоровья, выбран Игни) выбрал знак Игни
	// Generator seed: 1555514764437148742
	// Гуль (1491 здоровья) получает 9 урона
	// Generator seed: 1555514764437165489
	// Гуль (0 здоровья) получает 1024 урона
	// Гуль (0 здоровья) погибает
	// Generator seed: 1555514764437179901
	// Гуль (497 здоровья) получает 303 урона
}
